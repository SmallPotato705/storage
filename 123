from fastapi import FastAPI

from fastapi.responses import StreamingResponse

import cv2

from io import BytesIO

# import RPi.GPIO as GPIO



from gpiozero import InputDevice



desired_width = 1280

desired_height = 720



PORT_01_GPIO = 6

PORT_02_GPIO = 13

PORT_03_GPIO = 19

PORT_USC_GPIO = 26



# GPIO.setmode(GPIO.BCM)





# GPIO.setup(21, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

# GPIO.setup(20, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

# GPIO.setup(16, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)





# GPIO.setup(6, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

# GPIO.setup(26, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

# GPIO.setup(13, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

# GPIO.setup(19, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)



# ~ input_device21 = InputDevice(21)

# ~ input_device20 = InputDevice(20)

# ~ input_device16 = InputDevice(16)



input_device6 = InputDevice(PORT_01_GPIO)

input_device13 = InputDevice(PORT_02_GPIO)

input_device19 = InputDevice(PORT_03_GPIO)

input_device26 = InputDevice(PORT_USC_GPIO)



mode = ["clean", "clean", "clean"]



app = FastAPI()





# =============================================================================

# Video0 -> GPIO21

# =============================================================================

@app.get("/Video0")

def capture_photo0():

    camera = cv2.VideoCapture(0)

    jpeg_bytesio = []

    

    if camera.isOpened():

    

        camera.set(cv2.CAP_PROP_FRAME_WIDTH, desired_width)

        camera.set(cv2.CAP_PROP_FRAME_HEIGHT, desired_height)

    

        ret, frame = camera.read()

        

        # resized_frame = cv2.resize(frame, (300, 300))

        

        x1, y1 = (frame.shape[1] - 400) // 2, (frame.shape[0] - 400) // 2

        x2, y2 = x1 + 400, y1 + 400

        resized_frame = frame[y1:y2, x1:x2]

        

        _, jpeg = cv2.imencode(".jpg", resized_frame)

    

        jpeg_bytesio = BytesIO(jpeg.tobytes())

        

        camera.release()



    return StreamingResponse(content=jpeg_bytesio, media_type="image/jpeg")



# ~ @app.get("/gpio21")

# ~ def gpio21():

    # ~ gpio_value = input_device21.value



    # ~ gpio_bytes = f"GPIO Value: {gpio_value}".encode('utf-8')



    # ~ return StreamingResponse(iter([gpio_bytes]), media_type="text/plain")



# =============================================================================

# Video02 -> GPIO20

# =============================================================================

@app.get("/Video2")

def capture_photo2():

    camera = cv2.VideoCapture(2)

    jpeg_bytesio = []

    

    if camera.isOpened():



        camera.set(cv2.CAP_PROP_FRAME_WIDTH, desired_width)

        camera.set(cv2.CAP_PROP_FRAME_HEIGHT, desired_height)

    

        ret, frame = camera.read()

        

        x1, y1 = (frame.shape[1] - 400) // 2, (frame.shape[0] - 400) // 2

        x2, y2 = x1 + 400, y1 + 400

        roi = frame[y1:y2, x1:x2]

        

        _, jpeg = cv2.imencode(".jpg", roi)

    

        jpeg_bytesio = BytesIO(jpeg.tobytes())

        

        camera.release()

    

    return StreamingResponse(content=jpeg_bytesio, media_type="image/jpeg")



# ~ @app.get("/gpio20")

# ~ def gpio20():

    # ~ gpio_value = input_device20.value



    # ~ gpio_bytes = f"GPIO Value: {gpio_value}".encode('utf-8')



    # ~ return StreamingResponse(iter([gpio_bytes]), media_type="text/plain")



# =============================================================================

# 

# =============================================================================

@app.get("/Video4")

def capture_photo4():

    camera = cv2.VideoCapture(4)

    jpeg_bytesio = []

    

    if camera.isOpened():

        camera.set(cv2.CAP_PROP_FRAME_WIDTH, desired_width)

        camera.set(cv2.CAP_PROP_FRAME_HEIGHT, desired_height)

    

        ret, frame = camera.read()

        

        x1, y1 = (frame.shape[1] - 400) // 2, (frame.shape[0] - 400) // 2

        x2, y2 = x1 + 400, y1 + 400

        roi = frame[y1:y2, x1:x2]

        

        _, jpeg = cv2.imencode(".jpg", roi)

    

        jpeg_bytesio = BytesIO(jpeg.tobytes())

        

        camera.release()

    

    return StreamingResponse(content=jpeg_bytesio, media_type="image/jpeg")



# ~ @app.get("/gpio16")

# ~ def gpio16():

    # ~ gpio_value = input_device16.value



    # ~ gpio_bytes = f"GPIO Value: {gpio_value}".encode('utf-8')



    # ~ return StreamingResponse(iter([gpio_bytes]), media_type="text/plain")





# =============================================================================

# 

# =============================================================================

@app.get("/Video6")

def capture_photo6():

    camera = cv2.VideoCapture(6)

    jpeg_bytesio = []

    

    if camera.isOpened():

        camera.set(cv2.CAP_PROP_FRAME_WIDTH, desired_width)

        camera.set(cv2.CAP_PROP_FRAME_HEIGHT, desired_height)

    

        ret, frame = camera.read()

        

        x1, y1 = (frame.shape[1] - 400) // 2, (frame.shape[0] - 400) // 2

        x2, y2 = x1 + 400, y1 + 400

        roi = frame[y1:y2, x1:x2]

        

        _, jpeg = cv2.imencode(".jpg", roi)

    

        jpeg_bytesio = BytesIO(jpeg.tobytes())

        

        camera.release()

    

    return StreamingResponse(content=jpeg_bytesio, media_type="image/jpeg")



@app.get("/gpio06")

def gpio06():

    gpio_value = input_device6.value



    gpio_bytes = f"GPIO Value: {gpio_value}".encode('utf-8')



    return StreamingResponse(iter([gpio_bytes]), media_type="text/plain")



@app.get("/gpio26")

def gpio26():

    gpio_value = input_device26.value



    gpio_bytes = f"GPIO Value: {gpio_value}".encode('utf-8')



    return StreamingResponse(iter([gpio_bytes]), media_type="text/plain")



@app.get("/gpio13")

def gpio13():

    gpio_value = input_device13.value



    gpio_bytes = f"GPIO Value: {gpio_value}".encode('utf-8')



    return StreamingResponse(iter([gpio_bytes]), media_type="text/plain")



@app.get("/gpio19")

def gpio19():

    gpio_value = input_device19.value



    gpio_bytes = f"GPIO Value: {gpio_value}".encode('utf-8')



    return StreamingResponse(iter([gpio_bytes]), media_type="text/plain")

    

@app.post("/setMemory")

def receive_data(value: dict):

    received_value = value.get("value")

    mode[0] = received_value

    print(mode[0])

    return {"OK"}

    

@app.post("/setRelay")

def receive_data(value: dict):

    received_value = value.get("value")

    print(mode[0])

    return {"OK"}

    

if __name__ == "__main__":

    import uvicorn



    # ?? FastAPI ?蝔?

    uvicorn.run(app, host="192.168.68.121", port=8000)

    

    #uvicorn.run(app, host="172.20.10.2", port=8000)

    #uvicorn.run(app)

